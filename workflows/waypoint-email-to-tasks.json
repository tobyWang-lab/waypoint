{
  "name": "WAYPOINT Email to Tasks",
  "nodes": [
    {
      "id": "gmail-trigger-unread",
      "name": "Gmail Trigger - Unread Inbox",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1,
      "position": [
        240,
        300
      ],
      "parameters": {
        "resource": "message",
        "labelIds": [
          "INBOX"
        ],
        "q": "is:unread -label:WAYPOINT-Processed",
        "includeSpamTrash": false
      },
      "credentials": {
        "gmailOAuth2": {
          "id": "PLACEHOLDER",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "id": "gmail-message-detail",
      "name": "Gmail Message Detail",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [
        520,
        300
      ],
      "parameters": {
        "resource": "message",
        "operation": "get",
        "messageId": "={{$json.id}}",
        "format": "full",
        "options": {
          "includeSpamTrash": false
        }
      },
      "credentials": {
        "gmailOAuth2": {
          "id": "PLACEHOLDER",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "id": "cap-input-size",
      "name": "Cap Input Size",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        300
      ],
      "parameters": {
        "language": "javascript",
        "code": "const MAX_BODY_CHARS = 8000;\nconst MAX_ATTACHMENT_BYTES = 5 * 1024 * 1024; // 5MB total\n\nconst body = $json.textPlain || $json.textHtml || $json.snippet || \"\";\nconst attachments = Array.isArray($json.attachments) ? $json.attachments : [];\n\nconst totalAttachmentBytes = attachments.reduce((sum, file) => {\n  const size = file.size || file.fileSize || file.bytes || 0;\n  return sum + (Number.isFinite(size) ? size : 0);\n}, 0);\n\nconst cappedBody = body.length > MAX_BODY_CHARS ? body.slice(0, MAX_BODY_CHARS) : body;\nconst oversizedBody = body.length > MAX_BODY_CHARS;\nconst oversizedAttachments = totalAttachmentBytes > MAX_ATTACHMENT_BYTES;\n\nlet status = \"success\";\nlet statusReason = null;\n\nif (oversizedBody || oversizedAttachments) {\n  status = \"partial\";\n  const reasons = [];\n  if (oversizedBody) reasons.push(`Body capped at ${MAX_BODY_CHARS} chars`);\n  if (oversizedAttachments) reasons.push(`Attachments capped at ${MAX_ATTACHMENT_BYTES} bytes`);\n  statusReason = reasons.join(\"; \");\n}\n\nreturn [{\n  ...$json,\n  cappedBody,\n  totalAttachmentBytes,\n  status,\n  statusReason\n}];"
      }
    },
    {
      "id": "ai-noise-filter",
      "name": "AI Agent - Noise Filter",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1,
      "position": [
        1080,
        300
      ],
      "parameters": {
        "options": {
          "systemMessage": "You are an email classification assistant. Your task is to determine if an email is NOISE or SIGNAL.\n\nNOISE categories:\n- Advertisement: Promotional emails, marketing campaigns, sales offers\n- Newsletter: Subscription-based informational emails, digests, updates\n- Notification: Automated system notifications, alerts, confirmations\n\nSIGNAL: Legitimate business communication requiring human attention.\n\nRULES:\n1. Analyze ONLY the email subject, sender, and body content provided.\n2. Do NOT fabricate or assume information not present in the input.\n3. Return a valid JSON object with the exact structure specified.\n4. If uncertain, classify as SIGNAL to avoid missing important emails.\n\nOutput JSON format:\n{\n  \"classification\": \"Noise\" | \"Signal\",\n  \"noiseCategory\": \"Advertisement\" | \"Newsletter\" | \"Notification\" | null,\n  \"confidence\": 0.0-1.0\n}\n\nIf classification is \"Signal\", noiseCategory MUST be null."
        },
        "text": "=Classify this email:\n\nFrom: {{ $json.from }}\nSubject: {{ $json.subject }}\nBody:\n{{ $json.cappedBody }}"
      },
      "credentials": {
        "openAiApi": {
          "id": "PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "id": "route-noise",
      "name": "Route Noise",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1360,
        300
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-signal",
              "leftValue": "={{ $json.classification }}",
              "rightValue": "Signal",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      }
    },
    {
      "id": "set-skipped-noise",
      "name": "Set Skipped - Noise",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [
        1640,
        480
      ],
      "parameters": {
        "mode": "manual",
        "duplicateItem": false,
        "assignments": {
          "assignments": [
            {
              "id": "status",
              "name": "status",
              "value": "skipped",
              "type": "string"
            },
            {
              "id": "statusReason",
              "name": "statusReason",
              "value": "=Email classified as Noise ({{ $json.noiseCategory }})",
              "type": "string"
            }
          ]
        }
      }
    },
    {
      "id": "ai-intent-extraction",
      "name": "AI Agent - Intent & Extraction",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1,
      "position": [
        1640,
        300
      ],
      "parameters": {
        "options": {
          "systemMessage": "You are a task extraction assistant. Your role is to classify email intent and extract actionable waypoints.\n\nINTENT CATEGORIES:\n- Actionable: Email contains a direct request, task, or action item with or without a deadline\n- FYI: Informational email with no required action\n- Forward: Email explicitly asks to forward to another person\n\nWAYPOINT EXTRACTION (only for Actionable emails):\n- dueDate: Extract deadline in ISO 8601 format (YYYY-MM-DD). Return null if no date is mentioned. NEVER fabricate dates.\n- stakeholders: Array of names of key people mentioned. Return empty array [] if none found.\n- actionItems: Array of specific actions to be taken. Return empty array [] if none found.\n- title: One concise sentence summarizing the task (max 120 characters). Professional tone.\n\nRULES:\n1. Analyze ONLY the email content provided. Do NOT hallucinate or assume missing information.\n2. If dueDate cannot be confidently extracted, return null. NEVER guess.\n3. Return a valid JSON object with the exact structure specified.\n4. For FYI and Forward intents, waypoint fields should be null or empty arrays.\n5. Maintain strict adherence to the output schema.\n\nOutput JSON format:\n{\n  \"intent\": \"Actionable\" | \"FYI\" | \"Forward\",\n  \"intentConfidence\": 0.0-1.0,\n  \"title\": \"string (max 120 chars)\" | null,\n  \"dueDate\": \"YYYY-MM-DD\" | null,\n  \"stakeholders\": [\"string\"] | [],\n  \"actionItems\": [\"string\"] | [],\n  \"extractionConfidence\": 0.0-1.0\n}"
        },
        "text": "=Classify intent and extract waypoints from this email:\n\nFrom: {{ $('Gmail Message Detail').item.json.from }}\nSubject: {{ $('Gmail Message Detail').item.json.subject }}\nBody:\n{{ $('Cap Input Size').item.json.cappedBody }}"
      },
      "credentials": {
        "openAiApi": {
          "id": "PLACEHOLDER",
          "name": "OpenAI API"
        }
      }
    },
    {
      "id": "validate-task-card",
      "name": "Validate Task Card",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1920,
        300
      ],
      "parameters": {
        "language": "javascript",
        "code": "// Validate LLM output against Task Card schema\nconst llmOutput = $json;\nconst emailData = $('Gmail Message Detail').item.json;\nconst capData = $('Cap Input Size').item.json;\n\n// Valid enum values\nconst validIntents = ['Actionable', 'FYI', 'Forward'];\nconst validCategories = ['urgent', 'followup', 'blocked', 'completed', 'draft'];\n\nlet status = capData.status || 'success';\nlet statusReason = capData.statusReason || null;\nconst validationErrors = [];\n\n// Validate intent\nif (!llmOutput.intent || !validIntents.includes(llmOutput.intent)) {\n  validationErrors.push(`Invalid intent: ${llmOutput.intent}`);\n}\n\n// Validate title for Actionable\nif (llmOutput.intent === 'Actionable') {\n  if (!llmOutput.title || typeof llmOutput.title !== 'string') {\n    validationErrors.push('Missing or invalid title');\n  } else if (llmOutput.title.length > 120) {\n    validationErrors.push(`Title exceeds 120 chars: ${llmOutput.title.length}`);\n  }\n}\n\n// Validate dueDate format if present\nif (llmOutput.dueDate !== null && llmOutput.dueDate !== undefined) {\n  const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!dateRegex.test(llmOutput.dueDate)) {\n    validationErrors.push(`Invalid dueDate format: ${llmOutput.dueDate}`);\n  }\n}\n\n// Validate arrays\nif (llmOutput.stakeholders && !Array.isArray(llmOutput.stakeholders)) {\n  validationErrors.push('stakeholders must be an array');\n}\nif (llmOutput.actionItems && !Array.isArray(llmOutput.actionItems)) {\n  validationErrors.push('actionItems must be an array');\n}\n\n// Validate confidence scores\nif (llmOutput.intentConfidence !== undefined) {\n  const conf = parseFloat(llmOutput.intentConfidence);\n  if (isNaN(conf) || conf < 0 || conf > 1) {\n    validationErrors.push(`Invalid intentConfidence: ${llmOutput.intentConfidence}`);\n  }\n}\n\n// Set partial status if validation errors\nif (validationErrors.length > 0) {\n  status = 'partial';\n  const existingReason = statusReason ? statusReason + '; ' : '';\n  statusReason = existingReason + 'Validation: ' + validationErrors.join(', ');\n}\n\n// Build Task Card\nconst taskCard = {\n  id: require('crypto').randomUUID(),\n  title: llmOutput.title || emailData.subject?.slice(0, 120) || 'Untitled Task',\n  sourceLink: `https://mail.google.com/mail/u/0/#inbox/${emailData.id}`,\n  intent: llmOutput.intent || 'FYI',\n  dueDate: llmOutput.dueDate || null,\n  stakeholders: Array.isArray(llmOutput.stakeholders) ? llmOutput.stakeholders : [],\n  actionItems: Array.isArray(llmOutput.actionItems) ? llmOutput.actionItems : [],\n  priority: llmOutput.priority || null,\n  estimatedMinutes: llmOutput.estimatedMinutes || null,\n  category: validCategories.includes(llmOutput.category) ? llmOutput.category : 'followup',\n  createdAt: new Date().toISOString(),\n  status: status,\n  statusReason: statusReason,\n  metadata: {\n    emailMessageId: emailData.id,\n    processingDurationMs: Date.now() - ($execution.startedAt ? new Date($execution.startedAt).getTime() : Date.now()),\n    llmProvider: 'openai',\n    extractionConfidence: parseFloat(llmOutput.extractionConfidence) || null\n  }\n};\n\nreturn [taskCard];"
      }
    }
  ],
  "connections": {
    "Gmail Trigger - Unread Inbox": {
      "main": [
        [
          {
            "node": "Gmail Message Detail",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gmail Message Detail": {
      "main": [
        [
          {
            "node": "Cap Input Size",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cap Input Size": {
      "main": [
        [
          {
            "node": "AI Agent - Noise Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent - Noise Filter": {
      "main": [
        [
          {
            "node": "Route Noise",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Noise": {
      "main": [
        [
          {
            "node": "AI Agent - Intent & Extraction",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Set Skipped - Noise",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent - Intent & Extraction": {
      "main": [
        [
          {
            "node": "Validate Task Card",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null
}
